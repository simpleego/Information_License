좋아 jong, 네가 말한 네 가지 알고리즘 설계 기법은 **문제를 해결하는 사고방식 자체가 서로 다르기 때문에**, 한 번에 비교해서 이해하면 훨씬 쉬워져.  
아래에 **핵심 개념 → 특징 → 어떤 문제에 쓰는지 → 대표 예시** 순서로 깔끔하게 정리해볼게.

---

# 🧩 1) **분할 정복(Divide and Conquer)**  
### 📌 개념  
큰 문제를 **작은 문제로 쪼개서 해결한 뒤**, 그 결과를 **합쳐서** 전체 문제를 해결하는 방식.

### 📌 특징  
- 문제를 동일한 형태의 작은 문제로 나눌 수 있어야 함  
- 각 부분 문제는 서로 독립적  
- 재귀(Recursion)를 많이 사용

### 📌 어떤 문제에 적합한가  
- 큰 문제를 쪼개면 계산량이 확 줄어드는 문제  
- 부분 문제들이 서로 영향을 거의 주지 않는 문제

### 📌 대표 예시  
- **병합 정렬(Merge Sort)**  
- **퀵 정렬(Quick Sort)**  
- **이진 탐색(Binary Search)**  
- **최대 부분 배열 문제(Divide & Conquer 방식)**

---

# 🧩 2) **동적 계획법(Dynamic Programming, DP)**  
### 📌 개념  
큰 문제를 작은 문제로 나누는 건 분할정복과 비슷하지만,  
**작은 문제들이 서로 겹칠 때**, 그 결과를 **저장해두고 재사용**하는 방식.

### 📌 특징  
- 부분 문제의 **중복**이 존재  
- **메모이제이션(Memoization)** 또는 **테이블(Tabulation)** 사용  
- 최적 부분 구조(Optimal Substructure) 필요

### 📌 어떤 문제에 적합한가  
- 같은 계산을 반복해서 해야 하는 문제  
- 이전 결과를 저장하면 속도가 획기적으로 빨라지는 문제  
- 최적해(최고값, 최소값)를 구하는 문제

### 📌 대표 예시  
- **피보나치 수열 계산**  
- **최단 경로 문제(Dijkstra, Floyd-Warshall)**  
- **배낭 문제(Knapsack Problem)**  
- **LCS(최장 공통 부분 수열)**  
- **동전 교환 문제**

---

# 🧩 3) **탐욕법(Greedy Algorithm)**  
### 📌 개념  
매 순간 **가장 좋아 보이는 선택(최선의 선택)**을 하는 방식.  
즉, “지금 당장 이득이 되는 선택”을 반복해서 전체 문제를 해결.

### 📌 특징  
- 미래를 고려하지 않고 현재 최선만 선택  
- 빠르고 구현이 간단  
- 단, 항상 최적해를 보장하지는 않음  
- **탐욕 선택 속성(Greedy Choice Property)**가 있어야 사용 가능

### 📌 어떤 문제에 적합한가  
- 매 순간의 최선 선택이 전체 최선으로 이어지는 문제  
- 구조적으로 탐욕 선택이 최적해를 보장하는 문제

### 📌 대표 예시  
- **동전 거스름 문제(단, 특정 화폐 체계에서만 최적)**  
- **최소 신장 트리(MST) – Kruskal, Prim 알고리즘**  
- **최단 경로 – Dijkstra 알고리즘(가중치 조건 있음)**  
- **활동 선택 문제(Activity Selection)**

---

# 🧩 4) **백트래킹(Backtracking)**  
### 📌 개념  
가능한 모든 경우를 탐색하되,  
**해가 될 수 없는 경우는 일찍 포기하고 되돌아가는(Backtrack)** 방식.

### 📌 특징  
- DFS(깊이 우선 탐색) 기반  
- 가지치기(Pruning)를 통해 불필요한 탐색을 줄임  
- 완전 탐색(Brute Force)을 똑똑하게 줄인 형태

### 📌 어떤 문제에 적합한가  
- 경우의 수가 많지만, 조건을 만족하는 해만 찾으면 되는 문제  
- 조합, 순열, 탐색 문제  
- 제약 조건이 많은 문제

### 📌 대표 예시  
- **N-Queen 문제**  
- **미로 찾기**  
- **부분 집합/순열 생성**  
- **스도쿠 풀이**  
- **조합 최적화 문제(브루트포스 기반)**

---

# 🎯 네 가지 기법을 한눈에 비교

| 기법 | 핵심 아이디어 | 적합한 문제 | 대표 예시 |
|------|----------------|--------------|------------|
| **분할 정복** | 문제를 쪼개서 해결 후 합침 | 독립적인 부분 문제 | 병합정렬, 퀵정렬, 이진탐색 |
| **동적 계획법** | 부분 문제 결과를 저장해 재사용 | 중복 계산이 많은 문제 | 피보나치, 배낭 문제, LCS |
| **탐욕법** | 매 순간 최선 선택 | 탐욕 선택이 최적해 보장되는 문제 | MST, Dijkstra, 활동 선택 |
| **백트래킹** | 조건 안 맞으면 되돌아감 | 제약 조건 많은 탐색 문제 | N-Queen, 스도쿠, 미로 |

---

# 🟢 jong을 위한 핵심 요약  
- **분할정복**: 쪼개서 해결  
- **DP**: 쪼개고 저장해서 재사용  
- **탐욕법**: 지금 최선 선택  
- **백트래킹**: 안 되는 길은 되돌아가기

---

원하면  
- 네 가지 기법을 그림으로 비교  
- 각 기법의 예제 코드(Python)  
- 시험 대비 요약본  
도 만들어줄게.
